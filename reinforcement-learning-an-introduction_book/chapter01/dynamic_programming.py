
###########################################################################
#                                動態規劃                                  #
###########################################################################
"""
============= 數學歸納法 =============
定理：
    1. Y_0 成立。
    2. 假設 Y_1, Y_2, ..., Y_k 成立，如果能證明 Y_{k+1} 一定成立，
    3. 則 Y_n 成立，對所有的正整數 n

利用數學歸納法解決問題：
    將一個問題分成多個小問題來解決，小問題又可以分成更小的子問題來解決，一直將問題切割下去
    ，一直切分到可以做得出來為止。
    如果：
        1. 切分的子問題，形式都和母問題一樣，只是複雜度不一樣，
        2. 母問題的解可以由子問題的解來組成，
    那由數學歸納得知，我們可得原始問題的解

    母問題 -> 拆分成子問題 --> 求解子問題 --> 合併子問題的解 --> 得到母問題的解 

例子：
    - Factorial：n! = n * (n-1)!
    - Fibonacci number： F_n = F_{n-1} + F_{n-2}
    - 在曼哈頓，由起點到終點的走法數(不回頭)：N[m, n] = N[m-1, n] + N[m, n-1]
    - 有 2, 5, 7 元硬幣，用最少硬幣數量拼出 27 元幣值
    - 64*64 的白色棋盤如果一格塗黑，可否用 2*2 少一格的紙片將白色部位蓋滿
    - 數列排序問題，mergesort


============= Iteration(迭代) or Recursion(遞迴)： =============
概念：
    一個問題如果能用數學歸納法的形式寫出來，基本上演算法就已經得到了。再來只是決定用迭代
    方式還是遞迴方式來寫程式。但是解一個問題最難的也是如何找出這個數學歸納法的形式。
    底下都用 factorial 當做例子，求 n!=factorial(n)，

Iteration(迭代)： 函數裡面會有 loop
    # n! = 1 * 2 * 3 ... * n
    def factorial(n):
        output = 1
        for i in range(2, n+1):
            output = output * i
        return output 

Recursion(遞迴)：函數裡面會呼叫本身函數
    # n! = n * (n-1)!
    def factorial(n):
        if n == 1:
            return 1
        return n * factorial(n-1)


============= 演算法架構： 分治法和動態規劃法 =============
概念：
    分治法和動態規劃法只是將上述的數學歸納法問題分成兩個類型，子問題彼此間究竟獨立或不獨立
                    |-- 子問題彼此平行 -> 分治法
    數學歸納法問題  --
                    |-- 子問題互有重疊 -> 動態規劃法

分治法 (Divdide and Conquer)：
    子問題間彼此平行獨立，抽象來說，如果 A 分成 B1 和 B2 兩個子問題，則 B1 再分下去的所有
    子問題並不會和 B2 再分下去的所有子問題有重疊，不會有重複計算的問題
        
                    |-- C1
            -- B1 --|
            |       |-- C2
        A --|                   ====> {C1, C2} 交集 {C3, C4} = empty 
            |       |-- C3
            -- B2 --|
                    |-- C4
    
    例子：
        - Factorial：n! = n * (n-1)!
        - 64*64 的白色棋盤如果一格塗黑，可否用 2*2 少一格的紙片將白色部位蓋滿
        - 數列排序問題，mergesort

動態規劃法(Dynamic Programming)：
    子問題間彼此並非平行獨立，抽象來說，如果 A 分成 B1 和 B2 兩個子問題，則 B1 再分下去
    的所有子問題會和 B2 再分下去的所有子問題有所重疊，存在重複計算的問題
        
                    |-- C1
            -- B1 --|
            |       |-- C2
        A --|                   ==> B1 和 B2 都重複計算了 C2
            |       |-- C2
            -- B2 --|
                    |-- C3
    
    例子：
        - Fibonacci number： F_n = F_{n-1} + F_{n-2}
        - 在曼哈頓，由起點到終點的走法數(不回頭)：N[m, n] = N[m-1, n] + N[m, n-1]
        - 有 2, 5, 7 元硬幣，用最少硬幣數量拼出 27 元幣值
    
    動態規劃法是 Richard E. Bellman 在 1953 年提出，當時他在美國軍方工作，取名該演算法
    叫做 Dynamic Programming 的原因是聽起來比較屌，老闆才會願意給研究資金。
    思路很簡單，空間換時間，算過的結果就存起來，就解決重複計算問題了。
    底下用 Fibonacci number 當做例子：F(n) = F(n-1) + F(n-2)
    
    問題： Get F(n) for all n <= 20
    
    DP 解法一： Iteration(迭代)
        # F0, F1, F2, F3 ..., F20
        def fibonacci(n):
            f_list = [1, 1]    # 將結果存在 f_list, F0 = 1 and F1 = 1
            for i in range(2, n+1):
                fi = f_list[i-1] + f_list[i-2]
                f_list.append(fi)
        return f_list

    DP 解法二：
        # F(n) = F(n-1) + F(n-2)
        N = 20
        f_list = [None] * (N+1)
        f_list[0] = 1
        f_list[1] = 1
        def fibonacci(n, f_list):
            if f_list[n] is None:
                f_list[n] = fibonacci(n-1, f_list) + fibonacci(n-2, f_list)
            return f_list[n]

"""






# ========================= 防雷分隔線：作業參考解答 =========================






##########################################################################
#                        Case 1: Fibonacci number                        #
##########################################################################



##########################################################################
#                        Case 2: 曼哈頓問題                                #
##########################################################################



##########################################################################
#                        Case 3: 最少硬幣問題                              #
##########################################################################